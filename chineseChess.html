<!DOCTYPE html>
<html>
<head>
    <title>Chinese Chess Game</title>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .chessboard {
            width: 540px;
            height: 600px;
            background-color: #deb887;
            border: 2px solid #8b4513;
            position: relative;
            padding: 2px;
            box-sizing: content-box;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="540" height="600" viewBox="0 0 540 600"><rect width="540" height="600" fill="none" stroke="black" stroke-width="2"/><path d="M0,60 L540,60 M0,120 L540,120 M0,180 L540,180 M0,240 L540,240 M0,300 L540,300 M0,360 L540,360 M0,420 L540,420 M0,480 L540,480 M0,540 L540,540 M60,0 L60,600 M120,0 L120,600 M180,0 L180,600 M240,0 L240,600 M300,0 L300,600 M360,0 L360,600 M420,0 L420,600 M480,0 L480,600" stroke="black" stroke-width="1"/></svg>');
        }
        
        .piece {
            width: 50px;
            height: 50px;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            border-radius: 50%;
            z-index: 10;
        }
        
        .piece.red {
            color: red;
        }
        
        .piece.black {
            color: black;
        }
        
        .piece.selected {
            background-color: rgba(0, 255, 0, 0.5);
        }
        
        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .message-panel {
            width: 300px;
            height: 200px;
            border: 1px solid #ccc;
            overflow-y: auto;
            background-color: white;
            padding: 10px;
        }
        
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            padding: 10px;
            font-size: 16px;
        }
        
        input {
            padding: 5px;
            font-size: 16px;
        }
        
        label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Chinese Chess Game</h1>
    
    <div>
        <label for="roomId">Room ID:</label>
        <input type="text" id="roomId" placeholder="Enter room ID" readonly>
        <label for="name">Name:</label>
        <input type="text" id="name" placeholder="Enter name">
        <span id="status"><span style="color: red;">未连接</span></span>
    </div>
    
    <script>
        // 从URL参数中获取值并设置到对应的输入字段
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            
            const chessId = params.get('chessId');
            const name = params.get('name');
            const roomId = params.get('roomId');
            const player1 = params.get('player1');
            const player2 = params.get('player2');
            
            if (chessId) document.getElementById('chessId').value = chessId;
            if (name) document.getElementById('name').value = name;
            if (roomId) document.getElementById('roomId').value = roomId;
            if (player1) document.getElementById('player1').value = player1;
            if (player2) document.getElementById('player2').value = player2;
        }
        
        // 页面加载完成后执行
        window.addEventListener('DOMContentLoaded', getUrlParams);
    </script>
    
    <div class="game-container">
            <div>
                <div class="chessboard" id="chessboard">
                    <!-- Chess pieces will be added here dynamically -->
                </div>
                <div style="margin-top: 10px; text-align: center; font-weight: bold;">
                    点击棋子选择，再点击目标位置移动
                </div>
            </div>
            
            <div class="control-panel">
                <div class="message-panel">
                    <h2>Messages:</h2>
                    <ul id="messages"></ul>
                </div>
                
                <div class="control-buttons">
                    <button onclick="sendMessage()">Send Message</button>
                    <button onclick="resetGame()">Reset Game</button>
                    <div>
                        <label for="chessId">Chess ID:</label>
                        <input type="text" id="chessId" placeholder="Enter chess ID">
                    </div>
                    <div>
                        <label for="player1">Player 1:</label>
                        <input type="text" id="player1" placeholder="Enter player 1">
                    </div>
                    <div>
                        <label for="player2">Player 2:</label>
                        <input type="text" id="player2" placeholder="Enter player 2">
                    </div>
                    <div>
                        <label for="count">Count:</label>
                        <input type="text" id="count" placeholder="Enter count">
                    </div>
                    <div>
                        <label for="content">Content:</label>
                        <input type="text" id="content" placeholder="Enter content">
                    </div>
                </div>
            </div>
        </div>

    <script>
        var ws;
        var selectedPiece = null;
        var currentPlayer = 'red'; // 红方先走
        
        // 象棋棋子的初始位置
        var initialPieces = [
            // 红方棋子
            { id: 'r1', type: '車', color: 'red', x: 0, y: 9 },
            { id: 'r2', type: '馬', color: 'red', x: 1, y: 9 },
            { id: 'r3', type: '相', color: 'red', x: 2, y: 9 },
            { id: 'r4', type: '仕', color: 'red', x: 3, y: 9 },
            { id: 'r5', type: '帥', color: 'red', x: 4, y: 9 },
            { id: 'r6', type: '仕', color: 'red', x: 5, y: 9 },
            { id: 'r7', type: '相', color: 'red', x: 6, y: 9 },
            { id: 'r8', type: '馬', color: 'red', x: 7, y: 9 },
            { id: 'r9', type: '車', color: 'red', x: 8, y: 9 },
            { id: 'r10', type: '炮', color: 'red', x: 1, y: 7 },
            { id: 'r11', type: '炮', color: 'red', x: 7, y: 7 },
            { id: 'r12', type: '兵', color: 'red', x: 0, y: 6 },
            { id: 'r13', type: '兵', color: 'red', x: 2, y: 6 },
            { id: 'r14', type: '兵', color: 'red', x: 4, y: 6 },
            { id: 'r15', type: '兵', color: 'red', x: 6, y: 6 },
            { id: 'r16', type: '兵', color: 'red', x: 8, y: 6 },
            
            // 黑方棋子
            { id: 'b1', type: '車', color: 'black', x: 0, y: 0 },
            { id: 'b2', type: '馬', color: 'black', x: 1, y: 0 },
            { id: 'b3', type: '象', color: 'black', x: 2, y: 0 },
            { id: 'b4', type: '士', color: 'black', x: 3, y: 0 },
            { id: 'b5', type: '將', color: 'black', x: 4, y: 0 },
            { id: 'b6', type: '士', color: 'black', x: 5, y: 0 },
            { id: 'b7', type: '象', color: 'black', x: 6, y: 0 },
            { id: 'b8', type: '馬', color: 'black', x: 7, y: 0 },
            { id: 'b9', type: '車', color: 'black', x: 8, y: 0 },
            { id: 'b10', type: '炮', color: 'black', x: 1, y: 2 },
            { id: 'b11', type: '炮', color: 'black', x: 7, y: 2 },
            { id: 'b12', type: '卒', color: 'black', x: 0, y: 3 },
            { id: 'b13', type: '卒', color: 'black', x: 2, y: 3 },
            { id: 'b14', type: '卒', color: 'black', x: 4, y: 3 },
            { id: 'b15', type: '卒', color: 'black', x: 6, y: 3 },
            { id: 'b16', type: '卒', color: 'black', x: 8, y: 3 }
        ];
        
        var pieces = [];
        
        function connectWebSocket() {
            const wsUrl = window.WEBSOCKET_SERVER || 'http://localhost:8080';
            // const wsUrl = window.WEBSOCKET_SERVER || 'https://evsmcc.pythonanywhere.com';

            console.log('Connecting to WebSocket server:', wsUrl);
            
            // 配置Socket.IO连接，仅使用长轮询模式兼容PythonAnywhere
            socket = io(wsUrl, {
                transports: ['polling'], // 仅使用长轮询，禁用WebSocket
                upgrade: false, // 禁用协议升级
                timeout: 20000,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            // 连接成功
            socket.on('connect', function() {
                console.log('Connected to server');
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.innerHTML = '<span style="color: green;">已连接</span>';
                }
                
                // 发送加入房间的消息
                socket.emit('join', {
                    roomId: parseInt(roomId),
                    name: name,
                    chessId: chessId
                });
            });
            
            // 连接断开
            socket.on('disconnect', function() {
                console.log('Disconnected from server');
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.innerHTML = '<span style="color: red;">已断开</span>';
                }
            });
            
            // 连接错误
            socket.on('connect_error', function(error) {
                console.error('Connection error:', error);
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.innerHTML = '<span style="color: red;">连接错误: ' + error + '</span>';
                }
            });
            
            // 监听聊天消息
            socket.on('chat', function(data) {
                console.log('Received chat message:', data);
                const messagesList = document.getElementById('messages');
                if (messagesList) {
                    const messageItem = document.createElement('li');
                    messageItem.textContent = `${data.name}: ${data.content}`;
                    messagesList.appendChild(messageItem);
                    messagesList.scrollTop = messagesList.scrollHeight;
                } else {
                    console.error('Messages element not found');
                }
            });
            
            // 监听棋子移动消息
            socket.on('move', function(data) {
                console.log('Received move:', data);
                if (data.from && data.to && data.piece) {
                    movePiece(data.from, data.to, data.piece);
                }
            });
            
            // 监听棋盘状态同步
            socket.on('boardState', function(data) {
                console.log('Received board state:', data);
                if (data.board) {
                    syncBoardState(data.board);
                }
            });
            
            // 监听连接状态
            socket.on('status', function(data) {
                console.log('Status:', data.msg);
            });
        }
        
        // 从URL参数中获取roomId
        // 初始化棋盘
        function initChessboard() {
            var chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            
            // 添加棋盘点击事件
            chessboard.onclick = function(event) {
                // 计算点击位置对应的棋盘坐标
                var rect = chessboard.getBoundingClientRect();
                var x = Math.floor((event.clientX - rect.left) / 60);
                var y = Math.floor((event.clientY - rect.top) / 60);
                
                // 移动选中的棋子到点击位置
                movePiece(x, y);
            };
            
            // 创建棋子
            pieces = JSON.parse(JSON.stringify(initialPieces));
            
            pieces.forEach(function(piece) {
                createPiece(piece);
            });
            
            // 显示当前玩家回合
            updateCurrentPlayerDisplay();
        }
        
        // 创建棋子
        function createPiece(piece) {
            var chessboard = document.getElementById('chessboard');
            var pieceElement = document.createElement('div');
            
            pieceElement.className = 'piece ' + piece.color;
            pieceElement.id = piece.id;
            pieceElement.textContent = piece.type;
            
            // 设置棋子位置，确保在棋盘边界内
            var leftPos = Math.min(Math.max(piece.x * 60 + 5, 5), 485);
            var topPos = Math.min(Math.max(piece.y * 60 + 5, 5), 545);
            pieceElement.style.left = leftPos + 'px';
            pieceElement.style.top = topPos + 'px';
            
            // 添加点击事件
            pieceElement.onclick = function() {
                selectPiece(piece);
            };
            
            chessboard.appendChild(pieceElement);
        }
        
        // 选择棋子
        function selectPiece(piece) {
            // 只能选择当前玩家的棋子
            if (piece.color !== currentPlayer) {
                return;
            }
            
            // 如果已经选中了一个棋子，取消选中
            if (selectedPiece) {
                document.getElementById(selectedPiece.id).classList.remove('selected');
            }
            
            // 选中新的棋子
            selectedPiece = piece;
            document.getElementById(piece.id).classList.add('selected');
        }
        
        // 移动棋子
        function movePiece(toX, toY) {
            if (!selectedPiece) {
                return;
            }
            
            // 验证移动是否合法（这里简化处理，实际象棋规则更复杂）
            if (!isValidMove(selectedPiece, toX, toY)) {
                return;
            }
            
            // 检查目标位置是否有棋子，如果有且是对方棋子则吃掉
            var targetPiece = pieces.find(function(p) {
                return p.x === toX && p.y === toY;
            });
            
            if (targetPiece) {
                // 不能吃自己的棋子
                if (targetPiece.color === selectedPiece.color) {
                    return;
                }
                
                // 从棋盘上移除被吃掉的棋子
            var targetElement = document.getElementById(targetPiece.id);
            targetElement.parentNode.removeChild(targetElement);
            
            // 从数组中移除被吃掉的棋子
            pieces = pieces.filter(function(p) {
                return p.id !== targetPiece.id;
            });
            
            // 检查是否吃掉了将/帅
            if (targetPiece.type === '將' || targetPiece.type === '帥') {
                // 游戏结束
                setTimeout(function() {
                    alert((targetPiece.color === 'red' ? '黑方' : '红方') + '获胜!');
                    resetGame();
                }, 100);
                return;
            }
            }
            
            // 更新选中棋子的位置
            selectedPiece.x = toX;
            selectedPiece.y = toY;
            
            // 更新棋子在界面上的位置，确保在棋盘边界内
            var pieceElement = document.getElementById(selectedPiece.id);
            var newLeftPos = Math.min(Math.max(toX * 60 + 5, 5), 485);
            var newTopPos = Math.min(Math.max(toY * 60 + 5, 5), 545);
            pieceElement.style.left = newLeftPos + 'px';
            pieceElement.style.top = newTopPos + 'px';
            
            // 取消选中
            pieceElement.classList.remove('selected');
            selectedPiece = null;
            
            // 切换玩家
            currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
            
            // 更新当前玩家显示
            updateCurrentPlayerDisplay();
            
            // 发送棋盘状态到后端
            sendBoardState();
        }
        
        // 简化的移动验证（实际象棋规则更复杂）
        function isValidMove(piece, toX, toY) {
            // 确保目标位置在棋盘内
            if (toX < 0 || toX > 8 || toY < 0 || toY > 9) {
                return false;
            }
            
            // 简单的距离验证（实际规则需要根据棋子类型判断）
            var dx = Math.abs(piece.x - toX);
            var dy = Math.abs(piece.y - toY);
            
            // 至少要移动一格
            if (dx === 0 && dy === 0) {
                return false;
            }
            
            // 简化处理：只能横向或纵向移动，且步数不超过一定范围
            // 实际象棋规则需要根据棋子类型（車、馬、炮等）进行不同的判断
            return (dx === 0 || dy === 0) && (dx <= 8 && dy <= 9);
        }
        
        // 重置游戏
        function resetGame() {
            selectedPiece = null;
            currentPlayer = 'red';
            initChessboard();
        }
        
        // 更新当前玩家显示
        function updateCurrentPlayerDisplay() {
            var display = document.getElementById('current-player-display');
            if (!display) {
                display = document.createElement('div');
                display.id = 'current-player-display';
                display.style.marginTop = '10px';
                display.style.fontWeight = 'bold';
                document.querySelector('.game-container').prepend(display);
            }
            
            display.textContent = '当前回合: ' + (currentPlayer === 'red' ? '红方' : '黑方');
            display.style.color = currentPlayer;
        }
        
        // 根据接收到的数据更新棋盘
        function updateBoardFromData(boardData) {
            // 确保boardData存在且包含必要的属性
            if (!boardData || !Array.isArray(boardData.pieces)) {
                console.error('Invalid board data received:', boardData);
                return;
            }
            
            // 调用同步函数更新棋盘
            syncBoardState(boardData);
            
            // 更新玩家显示
            updateCurrentPlayerDisplay();
        }
        
        // 同步棋盘状态
        function syncBoardState(boardData) {
            if (!boardData || !Array.isArray(boardData.pieces)) {
                console.error('Invalid board data received:', boardData);
                return;
            }
            
            // 更新当前玩家
            currentPlayer = boardData.currentPlayer || 'red';
            
            // 更新棋子数组
            pieces = boardData.pieces.map(function(piece) {
                return {
                    id: piece.id || (piece.color + '-' + piece.x + '-' + piece.y),
                    type: piece.type,
                    color: piece.color,
                    x: piece.x,
                    y: piece.y
                };
            });
            
            // 重新渲染棋盘
            renderBoard();
            
            // 更新当前玩家显示
            updateCurrentPlayerDisplay();
        }
        
        // 重新渲染整个棋盘
        function renderBoard() {
            var chessboard = document.getElementById('chessboard');
            if (!chessboard) return;
            
            chessboard.innerHTML = '';
            
            // 重新创建所有棋子
            pieces.forEach(function(piece) {
                createPiece(piece);
            });
        }
        
        // 页面加载时自动连接WebSocket
        window.onload = function() {
            // 先获取URL参数并设置到对应的输入字段
            getUrlParams();
            
            // 设置部分输入框为只读
            document.getElementById('chessId').readOnly = true;
            document.getElementById('player1').readOnly = true;
            document.getElementById('player2').readOnly = true;
            
            connectWebSocket();
            initChessboard();
        };

        // 发送棋盘状态到后端
        function sendBoardState() {
            // 获取表单字段的值
            var roomId = document.getElementById('roomId').value;
            var name = document.getElementById('name').value;
            var chessId = document.getElementById('chessId').value;
            var player1 = document.getElementById('player1').value;
            var player2 = document.getElementById('player2').value;
            
            // 创建包含棋盘状态的JSON对象
            var boardState = {
                currentPlayer: currentPlayer,
                pieces: pieces,
                board: {
                    currentPlayer: currentPlayer,
                    pieces: pieces
                }
            };

            var messageObj = {
                roomId: parseInt(roomId),
                name: name,
                chessId: chessId,
                player1: player1,
                player2: player2,
                type: 'boardState',
                content: currentPlayer + "的回合",
                board: boardState
            };
            
            // 使用Socket.IO发送消息
            socket.emit('boardState', messageObj);
        }
        
        function sendMessage() {
            // 获取表单字段的值
            var roomId = document.getElementById('roomId').value;
            var name = document.getElementById('name').value;
            var chessId = document.getElementById('chessId').value;
            var player1 = document.getElementById('player1').value;
            var player2 = document.getElementById('player2').value;
            var content = document.getElementById('content').value;

            // 创建JSON对象
            var messageObj = {
                roomId: parseInt(roomId),
                name: name,
                chessId: chessId,
                player1: player1,
                player2: player2,
                type: 'chat',
                content: content
            };

            // 使用Socket.IO发送消息
            socket.emit('chat', messageObj);
            
            // 清空输入字段（除了roomId，因为它是连接参数）
            document.getElementById('content').value = '';
        }
    </script>
</body>
</html>